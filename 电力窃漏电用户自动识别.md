# 电力窃漏电用户自动识别

## 需求分析

电力计量自动化系统：各相电流、电压、功率因数等用电负荷数据及用电异常等终端报警信息

用这些数据提取出窃漏电用户的关键特征，构建该种用户识别模型。

数据挖掘建模目标：

1.归纳出窃漏电用户的关键特征，构建窃漏电用户的识别模型

**选择性抽取部分大用户用电负荷、终端报警、违约窃电处罚信息等原始数据；数据探索分析（去掉银行、税务等不会存在窃漏电行为的大用户）；对数据进行预处理（数据清洗、缺失值处理、数据变化），得到建模样本数据；训练模型、进行模型评价**；*根据实时诊断结果对模型优化和重构

2.利用实时监测数据，调用窃漏电用户识别模型实现实时诊断

实时抽取数据；对数据进行数据清洗、缺失值处理、数据变化，得到建模样本数据；放入模型得到诊断结果

## 数据抽取

原始数据：近5年所有窃漏电用户有关数据和不同用电类别正常用电用户共**208**个用户的所有数据，包括<u>用电负荷数据</u>、<u>终端报警数据</u>、<u>违约窃电处罚信息</u>、<u>用户档案资料</u>；包含每天是否由窃漏电情况的标识。

则获取数据包含以下：

1. 从营销系统抽取数据

   用户基本信息：用户名称、用户编号、用电地址、用电类别、报装容量、计量方式、电流互感器变比、电压互感器变化。

   **违约、窃电处理记录**：用电类别、计量方法、电流电压互感器。

   计量方法及依据。

2. 从计量自动化系统采集数据

   **实时负荷**：时间点、计量点、**总有功功率**、A/B/C相有功功率、A/B/C相电流、A/B/C相电压、A/B/C相功率因数。

   **终端报警**。

第l天的用电量，mi为第l天每隔15分钟的总有功功率（每0.25h采集一次用电负荷数据）：

<img src="pic\1568893088745.png" alt="1568893088745" style="zoom:50%;" />

## 数据探索分析

#对数据进行初步研究，发现数据内在规律特征，助于选择合适的数据。

采用**分布分析**和**周期性分析**。

1. **分布分析**

   统计出各个用电类别的窃漏电用户分布情况。

   <img src="pic\1568894841526.png" alt="1568894841526" style="zoom:50%;" />

   发现非居民类别不存在窃漏电情况，则接下来的分析**不考虑非居民类别**的用电数据。

2. **周期性分析**

正常用户，总体看用量较平稳，无太大波动：

<img src="pic\1568895346966.png" alt="1568895346966" style="zoom: 67%;" />

窃漏电用户，用电量出现明显下降趋势：

<img src="pic\1568895439525.png" alt="1568895439525" style="zoom:67%;" />

分析结论：正常用电到窃漏电即用电量**持续下降**的过程，即用户开始窃漏电时表现得重要特征。

## 数据预处理

### 数据清洗

即为建模筛选出需要的数据。

- 结合数据探索的分布分析，窃漏电用户样本可以**剔除非居民类别**的用电数据。
- 结合数据探索的周期性分析，节假日用电量明显低于工作日很多，则**剔除节假日**的用电数据。

### 缺失值处理

用户电量抽取过程中存在缺失现象，采用**拉格朗日插值法**对缺失值进行插补。

[^拉格朗日插值法：即线性插值，已知函数y=f(x)在给定互异点x0,x1上的值为y0=f(x0)，y1=f(x1)。线性插值即构造一个一次多项式：P1(x)=ax+b，使它满足条件：P1(x0)=y0，P1(x1)=y1。即用直线代替曲线，通常要求x0,x1比较小.]:

**拉格朗日插值法**：任给定F中2n+2个数x1，x2，……，xn+1，y1，y2，……，yn+1，其中x1，……xn+1互不相同，则存在唯一的次数不超过n的多项式pn(x)满足pn(xi)=yi，(i=1,2,...,n+1)：

<img src="pic\1568897324058.png" alt="1568897324058" style="zoom:80%;" />

算法：

i.确定自变量和因变量

ii.取出缺失值前后5个数据（遇到数据不存在或为空，直接将该数据舍去）

iii.将取出的10个数据组成一组，采用拉格朗日多项式插值公式：

<img src="pic\1568944277874.png" alt="1568944277874" style="zoom: 15%;" />

拉格朗日插值代码：

~~~python
#-*- coding:utf-8 -*-
import pandas as pd #数据分析库Pandas,有read_csv；read_sql；read_json；read_stata等
from scipy.interpolate import lagrange #拉格朗日插值函数

inputfile='../data/missing_data.xls' #输入需处理的数据途径，excel格式
outputfile='../tmp/missing_data_processed.xls' #输出途径
#虽然安装了pandas，但是要读取excel文件还是要安装xlrd、xlwt

data=pd.read_excel(inputfile,header=None) #header=None即不用文件中数据作表头，添加默认表头1、2...，制定表头：name=['xx','xxx',...]

#自定义列向量插值函数
#s为列向量，n为被插值的位置，k为前后取的数据个数，默认为5
def ployinterp_column(s,n,k=5):
    y=s[list(range(n-k,n))+list(range(n+1,n+1+k))] #取前后k个数，s[list( , )]
    y=y[y.notnull()] #剔除空值；pd.notnull()非空则输出True，空则输出False
    return lagrange(y.index,list(y))(n) #插值并返回插值结果
    #例：f=lagrange(x,y)
    #   f(3)=6
    
#逐个元素判断是否需要插值
for i in data.columns:
    for j in range(len(data)):
        if(data[i].isnull())[j]: #data[i]第i列，[j]第j个；为空则插值
            data[i][j]=ployinterp_column(data[i],j)
            
data.to_excel(outputfile,header=None,index=False) #输出结果
~~~

### 数据变化

通过采集的数据，构造可以表征窃漏电行为规律的建模指标。

<img src="pic\1569203445642.png" alt="1569203445642" style="zoom:67%;" />

**（1）电量趋势下降指标**

正常用户：用电量较为平稳

窃漏电用户：用电量呈下降趋势，而后趋于平缓

因此，选取统计前后几天作为统计窗口期，考虑期间的下降趋势：利用电量做直线拟合得到的斜率作为衡量，若斜率随时间不断下降则很有可能存在窃漏电行为。

将统计当天的前后5天作为统计窗口期，计算这11天内的电量趋势下降情况。计算这11天中每天的电量趋势，其中第i天的用电量趋势通过前后5天的用电量求得：

<img src="pic\1569204950170.png" alt="1569204950170" style="zoom:13%;" />

计算当天比前一天用电趋势为递减的天数：

<img src="pic\1569205051598.png" alt="1569205051598" style="zoom:67%;" />

则这11天的电量趋势下降指标：

<img src="pic\1569205035250.png" alt="1569205035250" style="zoom:67%;" />

**（2）线损指标**

线损率用于衡量供电线路的损失比例。

线路的线损率=[（该天的线路供电量 - 线路上各用户的总用电量）/ 该天的线路供电量 ] × 100%，即公式为：

<img src="pic\1569205658236.png" alt="1569205658236" style="zoom:67%;" />

若用户发生窃漏电，则当天的线损率会上升，为排除正常用电量波动，考虑用前后几天的线损率平均值，判断其增长是否大于1%，若大于则有窃漏电的可能性。

<img src="pic\1569205866350.png" alt="1569205866350" style="zoom:67%;" />

<img src="pic\1569205879255.png" alt="1569205879255" style="zoom:67%;" />

**（3）告警类指标**

终端报警包括电压缺相、电压断相、电流反极性等，计算这些次数总和作为告警类指标。

## 构建专家样本

对2009.1.1至2014.12.31所有窃漏电用户和正常用户的用电量、告警、线损数据和该用户在当天是否窃漏电的标识，按窃漏电评价指标进行处理并选取其中291个样本数据，得到专家样本库：

<img src="pic\1569206951575.png" alt="1569206951575" style="zoom:67%;" />

## 思路总结

<img src="pic\1569309228835.png" alt="1569309228835" style="zoom: 15%;" />

## 模型构建

### 构建窃漏电用户识别模型

随机选取20%作为测试样本、剩下作为训练样本。采用分类预测模型。常见分类预测模型：LM神经网络和CART决策树，分别用这两种方法构建窃漏电用户识别，并从中选择最优的类型分类。

#### （1）数据划分

对专家样本随机选取20%作为测试样本，剩下80%作为训练样本。

~~~python
#-*- coding:utf-8 -*-
import pandas as pd #数据分析库
from random import shuffle #随机函数shuffle用于打乱数据

datafile='../data/model.xls' #数据名
data=pd.read_excel(datafile) #用pandas读取excel数据，前三列是特征，第四列是标签
data=data.as_matrix() #pandas.as_matrix将表格转换为矩阵
shuflle(data) #随机打乱数据

p=0.8 #训练数据比例
train=data[:int(len(data)*p),:] #data列表从0到int(len(data)*p)行的所有列赋给train
test=data[int(len(data)*p):,;] #data列表从int(len(data)*p)行开始到矩阵最后一行的所有列赋给test
~~~

#### （2）LM神经网络

使用Keras库。设定LM神经网络的输入节点数为3，输出节点数为1，隐层节点数为10，使用Adam方法求解。在隐藏层使用Relu(x)=max(x,0)作为激活函数。LM神经网络模型：

~~~python
#构建LM神经网络分类模型，接数据划分代码
from keras.models import Sequential #导入神经网络初始化函数
from keras.layers.core import Dense, Activation #导入神经网络层函数、激活函数

netfile='../temp/net.model' #模型存储路径

net = Sequential() #建立神经网络
net.add(Dense(input_dim=3,output_dim=10)) #添加输入层（3节点）到隐藏层（10节点）的连接
net.add(Activation('relu')) #隐藏层使用relu激活函数
net.add(Dense(input_dim=10,output_dim=1)) #添加隐藏层（10节点）到输出层（1节点）的连接
net.add(Activation('sigmoid')) #输出层使用sigmoid激活函数
net.compile(loss = 'binary_crossentropy', optimizer = 'adam') #编译模型，使用adam方法求解

net.fit(data_train[:,:3], data_train[:,3], nb_epoch=1000, batch_size=1) #训练模型，循环1000次
net.save_weights(netfile) #保存模型

predict_result = net.predict_classes(train[:,:3]).reshape(len(train)) #预测结果变形
#keras用predict给出预测概率，用predict_classes给出预测类别，两者的预测结果都是n×1维数组，而不是通常的1×n

from cm_plot import * #导入自行编写的混淆矩阵可视化函数
cm_plot(train[:,3],predict_result).show() #显示混淆矩阵可视化结果
~~~

结果：混淆矩阵如图。分类准确率=（152+61）/（152+16+3+61）=91.81%。正常用户被误判占正常用户的16/（152+16）=9.52%。窃漏电用户被误判占窃漏电用户的3/（61+3）=4.69%。

<img src="pic\1569315224653.png" alt="1569315224653" style="zoom:50%;" />

#### （3）CART决策树

~~~python
#构建CART决策树模型，接数据划分代码
from sklearn.tree import DecisionTreeClassifier #导入决策树模型

treefile='../tmp/tree.pkl' #模型输出
tree=DecisionTreeClassifier #建立决策树模型
tree.fit(train[:,:3],train[:,:3]) #训练

#保存模型
from sklearn.externals import joblib
joblib.dump(tree,treefile)

from cm_plot import *
cm_plot(train[:,3],tree.predict(train[:,3])).show
#scikit-learn用predict方法直接给出预测结果
~~~

结果：混淆矩阵如图。分类准确率=（174+45）/（174+5+8+45）=94.40%。正常用户被误判占正常用户的5/（174+5）=2.79%。窃漏电用户被误判占窃漏电用户的8/（45+8）=15.09%。

<img src="pic\1569311599498.png" alt="1569311599498" style="zoom:50%;" />

### 模型评价

对于训练样本，LM神经网络和CART决策树的分类准确率相差不大，利用测试样本对两个模型进行进一步评价，采用ROC曲线评价方法。一个优秀分类器对应的ROC曲线应尽量靠近左上角。绘制ROC曲线代码（两个代码类似，放在一起展示）：

~~~python
from sklearn.metrics import roc_curve #导入ROC曲线函数
import matplotlib.pyplot as plt

predict_result=net.predict(test[:,:3]).reshape(len(test)) #预测结果变形
fpr1, tpr1, thresholds1 = roc_curve(test[:,3], predict_result, pos_label=1)
fpr2, tpr2, thresholds2 = roc_curve(test[:,3], tree.predict_proba(test[:,:3])[:,1], pos_label=1)
plt.plot(fpr1, tpr1, linewidth=2, label = 'ROC of LM', color = 'blue') #作出LM的ROC曲线
plt.plot(fpr2, tpr2, linewidth=2, label = 'ROC of CART', color = 'green') #作出CART的曲线
plt.xlabel('False Positive Rate') #坐标轴标签
plt.ylabel('True Positive Rate') #坐标轴标签
plt.ylim(0,1.05) #边界范围
plt.xlim(0,1.05) #边界范围
plt.legend(loc=4) #图例
plt.show() #显示作图结果
~~~

结果：

LM：

<img src="pic\1569315428682.png" alt="1569315428682" style="zoom:50%;" />

CART：

<img src="pic\1569311664988.png" alt="1569311664988" style="zoom:50%;" />

可知LM神经网络的ROC曲线比CART决策树的更靠近单位方形的左上角，LM神经网络ROC曲线下的面积更大，说明LM神经网络模型的分类性能更好。

### 进行窃漏电诊断

根据数据依据上述步骤进行诊断。



## 一些恶心心

**1.Windows 10下安装keras+theano**

Anaconda里面集成了很多关于python科学计算的第三方库，安装方便，Anaconda安装后numpy, nose, pip, python, scipy, mingw等一些科学计算必要的工具都默认安装。

Theano 是一个 Python 库，用来定义、优化和模拟数学表达式计算，用于高效的解决多维数组的计算问题，可用来做卷积神经网络方面的东西。

Keras是对Tensorflow或者Theano的再次封装，也就是以Tensorflow或Theano为后端，默认的后端是tensorflow，需要更改后端为theano。

（1）下载并安装Anaconda https://www.anaconda.com/distribution/#download-section

安装过程，选择配置环境变量勾上。

（2）安装Keras：pip install keras

（3）安装MinGW：

   下载：conda install mingw libpython

   配置环境：在环境变量中新增：

C:\Users\75681\Anaconda3\MinGW\bin

C:\Users\75681\Anaconda3\MinGW\x86_64-w64-mingw32\lib

   在C:\User\75681目录下新建文本.theanorc.txt，在文件中输入以下内容并保存：

[global] 
openmp=False 
[blas] 
ldflags= 
[gcc] 
cxxflags=-IC:\Users\75681\Anaconda3\MinGW 

（4）安装theano

   /*由于Keras依赖于Theano库，因此需要手动下载Theano库的压缩包。

   下载：在github上下载theano源码 https://github.com/Theano/Theano 点击Cloneor download按钮--> 点击Download ZIP即可开始下载。*/安装theano：

   \>\>\>conda install theano

安装完theano后，C:\Users\75681\Anaconda3\Lib\site-packages中会出现theano文件夹（用pip安装则好像没有）。

   配置环境变量：在环境变量中添加一个系统变量，变量名为PYTHONPATH，值为C:\Users\75681\Anaconda3\Lib\site-packages\theano

   测试：python；import theano 

-报错。AttributeError: module 'theano' has no attribute 'gof'。

-原因：配置文件修改后要**重启**。重启后报错：ImportError: cannot import name 'configparser' from 'theano.compat' (C:\User。。。。

-解决：删除系统变量PYTHONPATH即可。import theano没报错则成功。

（5）修改默认后端为theano

打开C:\Users\75681\.keras中的keras.json文件，将"backend": "tensorflow"改为"backend": "theano"。

\>\>\>import keras

Using Theano backend.

安装成功。

**2.安装pandas**

pip install pandas

**3.安装xlrd、xlwt**

pip install xlrd

pip install xlwt

**4.**pandas 0.21.0版本开始，list中缺失值的索引会引发**警告**：

![1569311029567](pic\1569311029567.png)

没影响，不管他。

**5.运行lm_model.py时**：

报错1：TypeError: `Dense` can accept only 1 positional arguments ('units',), but you passed the following positional arguments: [3, 10]

修改：由

~~~python
net.add(Dense(3, 10))
~~~

修改为

~~~python
net.add(Dense(input_dim=3, output_dim=10))
~~~

报错2：WARNING (theano.tensor.blas): Using NumPy C-API based implementation for BLAS functions.

……

Exception: ('The following error happened while compiling the node', Dot22(/dense_1_input, dense_1/kernel), '\n', 'Compilation failed (return status=1): c:/users/75681/anaconda3/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.0/../../../../x86_64-w64-mingw32/bin/ld.exe: cannot find -lblas\r. collect2.exe: error: ld returned 1 exit status\r. ', '[Dot22(/dense_1_input, dense_1/kernel)]')

修改：修改放在cmd同目录下的.theanorc.txt，将ldflags=-lblas等式的右端删去，即：

[blas] 
ldflags=